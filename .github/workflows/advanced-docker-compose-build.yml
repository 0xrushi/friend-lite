name: Build and Deploy Advanced (Docker Compose)

on:
  workflow_dispatch:
    inputs:
      version:
        description: Optional version tag override (e.g. v1.2.3)
        required: false
  push:
    branches: [ "main", "feat/*" ]
    paths:
      - "*"
      - "backends/advanced/**"
      - ".github/workflows/advanced-docker-compose-build.yml"
    tags:
      - "v*"


permissions:
  contents: read
  packages: write
  actions: read

env:
  REGISTRY: ghcr.io

jobs:
  detect-runner:
    runs-on: ubuntu-latest
    outputs:
      runner: ${{ steps.determine.outputs.runner }}
      label: ${{ steps.determine.outputs.label }}
    steps:
      - name: Determine runner target
        id: determine
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            try {
              const response = await github.rest.actions.listSelfHostedRunnersForRepo({
                owner,
                repo,
                per_page: 100
              });
              const available = response.data.runners.find((runner) => runner.status === 'online' && !runner.busy);

              if (available) {
                core.info(`Using self-hosted runner "${available.name}" with labels: ${available.labels.map((label) => label.name).join(', ')}`);
                core.setOutput('runner', '["self-hosted","linux","x64"]');
                core.setOutput('label', 'self-hosted');
                return;
              }

              core.info('No idle self-hosted runners available; falling back to "ubuntu-latest".');
            } catch (error) {
              core.warning(`Unable to query self-hosted runners (${error.message}); falling back to "ubuntu-latest".`);
            }

            core.setOutput('runner', '"ubuntu-latest"');
            core.setOutput('label', 'ubuntu-latest');

  build-and-deploy:
    needs: detect-runner
    runs-on: ${{ fromJson(needs.detect-runner.outputs.runner) }}
    timeout-minutes: 60
    env:
      ADVANCED_ENV: ${{ secrets.ADVANCED_ENV }}
    defaults:
      run:
        shell: bash
        working-directory: backends/advanced

    steps:
      - name: Show selected runner
        run: echo "Workflow running on ${{ needs.detect-runner.outputs.label }} runner"
        working-directory: .

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Copy .env.template to .env
        run: |
          set -euo pipefail
          copy_env() {
            local dir="$1"
            local template="${dir}/.env.template"
            local target="${dir}/.env"
            if [ -f "$template" ]; then
              echo "Copying $template to $target"
              cp "$template" "$target"
            else
              echo "$template not found; skipping"
            fi
          }

          copy_env .
          copy_env ../../extras/asr-services
          copy_env ../../extras/speaker-recognition

      - name: Create .env from secret (if provided)
        if: env.ADVANCED_ENV != ''
        run: |
          echo "Writing .env from ADVANCED_ENV secret"
          printf "%s\n" "${ADVANCED_ENV}" > .env

      - name: Source .env (if present)
        run: |
          if [ -f .env ]; then
            set -a
            # shellcheck disable=SC1091
            source .env
            set +a
          else
            echo ".env not found; continuing"
          fi

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [ "${{ github.ref_type }}" = "tag" ]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="sha-${GITHUB_SHA::7}"
          fi
          echo "VERSION=$VERSION" | tee -a "$GITHUB_OUTPUT"

      - name: Docker Compose build (only services with local Dockerfiles)
        run: |
          docker compose version
          docker compose build --pull

      - name: Docker Compose build (extras/asr-services parakeet-asr)
        run: |
          docker compose version
          docker compose -f ../../extras/asr-services/docker-compose.yml --project-directory ../../extras/asr-services build parakeet-asr

      - name: Docker Compose build (extras/speaker-recognition speaker-service)
        run: |
          docker compose version
          docker compose -f ../../extras/speaker-recognition/docker-compose.yml --project-directory ../../extras/speaker-recognition build speaker-service

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Tag and push built images to GHCR
        env:
          OWNER: ${{ github.repository_owner }}
          VERSION: ${{ steps.version.outputs.VERSION }}
        run: |
          set -euo pipefail
          OWNER_LC=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')
          # Only services with local Dockerfiles (skip redis/mongo/qdrant/caddy etc.)
          # Advanced project builds use the "advanced-" prefix; extras use explicit names
          services=("advanced-friend-backend" "advanced-workers" "advanced-webui" "parakeet-asr" "speaker-recognition")
          service_names=("friend-backend" "workers" "webui" "parakeet-asr" "speaker-recognition")

          # Get built images using docker images instead of docker compose images
          echo "Looking for built images..."
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}" | grep -E "(advanced-friend-backend|advanced-workers|advanced-webui|parakeet-asr|speaker-recognition)" || echo "No matching images found"

          for i in "${!services[@]}"; do
            svc="${services[$i]}"
            svc_name="${service_names[$i]}"
            
            # Look for images with the service name as repository
            img_id=$(docker images --format "{{.ID}}" --filter "reference=${svc}:*" | head -n1)
            if [ -z "${img_id:-}" ]; then
              echo "Skipping $svc_name (no built image found)"
              continue
            fi

            target_image="$REGISTRY/$OWNER_LC/$svc_name:$VERSION"
            echo "Tagging $img_id as $target_image"
            docker tag "$img_id" "$target_image"

            echo "Pushing $target_image"
            docker push "$target_image"
          done
